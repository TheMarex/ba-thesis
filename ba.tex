% Use UTF-8 encoding!!
% (c) Stefan Ulbrich, 2012

\documentclass[english,ngerman]{KITreprt}


%% -------------------------------
%% |  Information for PDF file   |
%% -------------------------------
\hypersetup{
 pdfauthor={Patrick Niklaus},
 pdftitle={Bachelor Thesis: Walking pattern generation for humanoid bipedal robots},
 pdfsubject={Not set},
 pdfkeywords={Not set}
}


%% --------------------------------
%% Obligatory Parameters:
%% --------------------------------

\renewcommand{\myname}{Patrick Niklaus}
\renewcommand{\mythesis}{\bachelorsthesis} %\mastersthesis, \bachelorsthesis, \protocol, \studienarbeit, \diplomarbeit
\renewcommand{\mytitle}{ Dynamically Stable Walking For Humanoid Bipedal Robots Based On Walking Patterns }
%\renewcommand{\myshorttitle}{Die offizielle \LaTeX-Vorlage des HIS}
\renewcommand{\myshorttitle}{}
\cfoot{\mytitle}

\renewcommand{\timestart}{15. September 2014}
%\renewcommand{\timeend}{\iflanguage{english}{February 7\textsuperscript{th},}{7. Februar} 2010}
%\newcommand{\advisor}{Name des betreuenden Mitarbeiters}
%\newcommand{\advisortwo}{Nur wenn n\"otig}

\newcommand{\clr}[2]{{\color{#1}{#2}}}
\newcommand{\todo}[1]{\marginpar{\clr{red}{#1}}}
\newcommand{\slpy}[1]{{\sloppy #1}}

\graphicspath{{./images/}}


\begin{document}


\selectlanguage{english}

%\selectlanguage{ngerman}


\maketitle

\tableofcontents

\chapter{Introduction}\label{introduction}

motivation, and a bit of overview of humanoid walking. I recommend to
leave it for later, start with the sections that you feel its easier to
write (usually, the ones that have more content).

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  motivation:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    navigating in human environments
  \end{itemize}
\item
  walking in humans:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    CoM movement, gait phases, differences to what we do here
  \end{itemize}
\item
  static vs.~dynamic walking
\item
  overview of models used for dynamic walking
\end{itemize}

\chapter{Models for humanoid walking}\label{models-for-humanoid-walking}

\section{The linear inverted pendulum
model}\label{the-linear-inverted-pendulum-model}

\todo{Use different name for CoM, $p$ will be rather used for the ZMP, maybe $c$?}

\todo{picture of 3D-LIPM}

A simple model for describing the dynamics of a bipedal robot during
single support phase is the 3D inverted pendulum. We reduce the body of
the robot to a point-mass at the center of mass and replace the support
leg by a mass-less telescopic leg which is fixed at a point on the
supporting foot. Initially this will yield non-linear equations that
will be hard to control. Howevery by constraining the movement of the
inverted pendulum to a fixed plane, we can derive a linear dynamic
system. This model called the 3D \emph{linear} inverted pendulum model
(short \emph{3D-LIPM}).

\section{The inverted pendulum}\label{the-inverted-pendulum}

To describe the dynamics of the inverted pendulum we are mainly
interested in the effect a given actuator torque has on the movement of
the pendulum.

For simplicity we assume that the base of the pendulum is fixed at the
origin of the current cartesian coordinate system. Thus we can describe
the position inverted pendulum by a vector $p = (x, y, z)$. We are going
to introduce an appropriate (generalized) coordinate system
$q = (\theta_R, \theta_P, r)$ to get an easy description of our actuator
torques: Let $m$ be the mass of the pendulum and $r$ the length of the
telescopic leg. $\theta_P$ and $\theta_R$ describe the corresponding
roll and pitch angles of the pose of the pendulum.
\todo{add image with angles here}

Now we need to find a mapping between forces in the cartesian coordinate
system and the generalized forces (the actuator torques). Let
$\Phi: \mathbb{R}^3 \longrightarrow \mathbb{R}^3, (\theta_R, \theta_P, r) \mapsto (x, y, z)$
be a function that maps the generalized coordinates to the cartesian
coordinates. Then the jacobian $J_\Phi = \frac{\partial p}{\partial q}$
maps the \emph{generalized velocites} to \emph{cartesian velocites}.
Furthermore we know that the transpose $J_\Phi^T$ maps \emph{cartesian
forces} $F = m (\ddot x, \ddot y, \ddot z)$ to \emph{generalized forces}
$(\tau_r, \tau_p, f)$.

We write $x$, $y$ and $z$ in terms of our generalized coordinates to
compute the corresponding jacobian $J_\Phi$. From the fact that the
$\theta_P$ is the angle between the projection of $p$ onto the
$xz$-plane and $p$ and $\theta_R$ the angle between $p$ and the
projection onto the $yz$ plane we can derive the following equations
\todo{reference paper}:

\begin{equation}
\begin{array}{lcll} \label{eq:lip-xyz}
x & = & r \cdot \sin \theta_P & =: r \cdot s_P\\
y & = & -r \cdot \sin \theta_R & =: -r \cdot s_R \\
z & = & \sqrt{r^2 - x^2 - y^2} = r \cdot \sqrt{1 - s_P^2 - s_R^2} & \\
\end{array}
\end{equation}

From which we can compute the jacobian by partial derivation:

\begin{equation} \label{eq:lip-jacobian}
J = \frac{\partial p}{\partial q} = \left( \begin{array}{rcl}
0 & r \cdot c_P & s_P \\
-r \cdot c_R & 0 & s_P \\
\frac{2 \cdot r \cdot s_P c_P}{\sqrt{1 - s_P^2 - s_R^2}} & \frac{2 \cdot r \cdot s_R c_R}{\sqrt{1 - s_P^2 - s_R^2}} & \sqrt{1 - s_P^2 - s_R^2}\\
\end{array}
\right)
\end{equation}

Using the equation of motion as given by

\begin{equation}
\begin{array}{lcr}
F & = & (J^T)^{-1} \Gamma + f_g \\
m \cdot
\left(\begin{array}{c}
\ddot x \\
\ddot y \\
\ddot z \\
\end{array}\right)
& = & (J^T)^{-1}
\left(\begin{array}{c}
\tau_R \\
\tau_P \\
f \\
\end{array}\right)
+
\left(\begin{array}{c}
0 \\
0 \\
-m \cdot g \\
\end{array}\right) \\
\end{array}
\end{equation}

and equations \ref{eq:lip-jacobian} and \ref{eq:lip-xyz} we can derive
the following equations:

\begin{equation} \label{eq:lip-dyn-y}
m(-z\ddot{y} + y\ddot{z}) = \frac{\sqrt{1 - s_P^2 - s_R^2}}{c_R} \cdot \tau_R + m g y
\end{equation}

\begin{equation} \label{eq:lip-dyn-x}
m(z\ddot{x} - x\ddot{z}) = \frac{\sqrt{1 - s_P^2 - s_R^2}}{c_P} \cdot \tau_P + m g x
\end{equation}

Observe that the terms of the left-hand side are not linear. To remove
that non-linearity we are going to use the \emph{linear} inverted
pendulum model.

\section{Linear Inverted Pendulum
Model}\label{linear-inverted-pendulum-model}

In a man-made environment it is fair to assume that the ground a robot
will walk on can be approximate by a slightly sloped plane. In most
cases it can even assumed that there is no slope at all.

The basic assumption in the next section will be that the CoM will have
a \emph{constant displacement} with regard to our ground plane. Thus we
can constrain the movement of the CoM to a plane that is parallel to the
ground plane. Note that this assumption is, depending on the walking
speed, only approximately true for human walking as shown by Orendurff
et. al. For slow to fast walking ($0.7$ m/s and $1.6$ m/s respectively)
the average displacement in $z$-direction was found to be between
$2.7cm$ and $4.81$ cm. While the walking patterns generated based on the
LIP-model will guarantee dynamic stability, they might not look natural
with regard to human walking.

\todo{cite Orendurff}

We are going to constrain the $z$ coordinate of our inverted pendulum to
a plane with normal vector $(k_x, k_y, -1)$ and $z$-displacement $z_c$:

\begin{equation} \label{eq:lip-z-plane}
z = k_x \cdot x + k_y \cdot y + z_c
\end{equation}

Subsequently the second derivative of $z$ can be described by:

\begin{equation} \label{eq:lip-z-div}
\ddot{z} = k_x \cdot \ddot{x} + k_y \cdot \ddot{y}
\end{equation}

Substituing \ref{eq:lip-z-plane} and \ref{eq:lip-z-div} into the
equations \ref{eq:lip-dyn-y} and \ref{eq:lip-dyn-x} yields the following
equations:

\begin{equation}
\ddot{y} = \frac{g}{z_c} y - \frac{k_x}{z_c} (x\ddot{y} - \ddot{x}y) - m z_c \cdot \tau_R \cdot \frac{\sqrt{1 - s_P^2 - s_R^2}}{c_R}
\end{equation}

\begin{equation}
\ddot{x} = \frac{g}{z_c} x + \frac{k_y}{z_c} (x\ddot{y} - \ddot{x}y) + m z_c \cdot \tau_P \cdot \frac{\sqrt{1 - s_P^2 - s_R^2}}{c_P}
\end{equation}

The term $x\ddot{y} - \ddot{x}y$ that is part of both equations is still
causing the equations to be non-linear. To make this equations linear we
will assume that our ground plane has no slope, thus $k_x = k_y = 0$ and
the non-linear terms will vanish.

Another problem is that the actuator torques $\tau_R$ and $\tau_P$ both
have non-linear factors $\frac{\sqrt{1 - s_P^2 - s_R^2}}{c_R}$ and
$\frac{\sqrt{1 - s_P^2 - s_R^2}}{c_P}$ respectively. This can be solved
by substituting with the following \emph{virtual inputs}:

\begin{equation}
\tau_P \cdot \frac{\sqrt{1 - s_P^2 - s_R^2}}{c_P} = u_P
\end{equation}

\begin{equation}
\tau_R \cdot \frac{\sqrt{1 - s_P^2 - s_R^2}}{c_R} = u_R
\end{equation}

Which yields our final description of the dynamics:

\begin{equation} \label{eq:lip-y}
\ddot{y} = \frac{g}{z_c} y - \frac{u_R}{m z_c}
\end{equation}

\begin{equation} \label{eq:lip-x}
\ddot{x} = \frac{g}{z_c} x + \frac{u_R}{m z_c}
\end{equation}

\todo{include pattern generation just based on 3D-LIPM, I don't understand how they derived the controller}

\section{The Zero Moment Point}\label{the-zero-moment-point}

A very popular approach to humanoid walking are schemes based on the
Zero Moment Point. One reason for that might be that it is very simple
to describe constrains for dynamic stability using this reference point.
As long as the following condition is met we will have full ground
contact of our support foot and thus can realize dynamically stable
walking: \emph{The ZMP is strictly inside the support polygone of the
support foot.}

For flat ground contact of our support foot with the floor the ZMP
corresponds with the position of the center of pressure (CoP). Indeed,
some author (notably Pratt) prefer to use the term CoP instead of ZMP.

The CoP of an object in contact with the ground can be computed as the
sum of all contact points $p_1, \dots, p_n$ weighted by the forces in
$z$-direction $f_{1z}, \dots, f_{nz}$ that is applied:

\begin{equation} \label{eq:zmp-definition}
p := \frac{\sum^N_{i=1}p_i f_{iz}}{\sum^N_{i=1} f_{iz}}
\end{equation}

An important fact (and the origin of its name) is that there are no
torques around the $x$ and $y$ axis at the ZMP:

\begin{equation}
\tau = \sum^N_{i=1} (p_i - p) \times f_i
\end{equation}

Splitting that up into each component using the definition of the cross
product yields:

\begin{equation}
\tau_x = \sum^N_{i=1} (p_{iy} - p_y) f_{iz} - \overbrace{(p_{iz} - p_z)}^{=0} f_{iy}
\end{equation}

\begin{equation}
\tau_y = \sum^N_{i=1} \overbrace{(p_{iz} - p_z)}^{=0} f_{ix} - (p_{ix} - p_x) f_{iz}
\end{equation}

\begin{equation}
\tau_z = \sum^N_{i=1} (p_{ix} - p_x) f_{iy} - (p_{iy} - p_y) f_{ix}
\end{equation}

Since we have flat ground contact, all contact points have the same
$z$-coordinate as the ZMP, thus we can simplify $\tau_x$ and $\tau_y$
to:

\begin{equation} \label{eq:zmp-torque-x}
\tau_x = \sum^N_{i=1} (p_{iy} - p_y) f_{iz} = \sum^N_{i=1} (p_{iy} f_{iz}) - (\sum^N_{i=0} f_{iz}) \cdot p_y
\end{equation}

\begin{equation}\label{eq:zmp-torque-y}
\tau_y = \sum^N_{i=1} - (p_{ix} - p_x) f_{iz} = \sum^N_{i=1} - (p_{ix} f_{iz}) + (\sum^N_{i=0} f_{iz}) \cdot p_x
\end{equation}

Furthermore we can use the corresponding components $p_x$ and $p_y$ from
the definition of the ZMP \ref{eq:zmp-definition} and substitude in the
equations \ref{eq:zmp-torque-x} and \ref{eq:zmp-torque-y}.

This will yield: $\tau_x = \tau_y = 0$.

Please note that $\tau_z$ will in general not be zero, nonetheless in
case of straight walking it is often assumed to be zero as well.

\subsection{The table-cart model}\label{section:table-cart}

The table-cart model is equivalent to the 3D-LIPM model discussed
before, but somewhat more intuitive for computing the resulting ZMP from
an CoM motion. The model consists of an (infinitely) large mass-less
table of height $z_c$, while the foot of the table has the shape of the
support polygone. Given a frictionless cart with mass $m$ that moves on
the table we can compute the resulting ZMP in the support foot. Please
note that the 3D-dimensional model is equivalent to having two
independent tables with two carts each in the $xz$ and $yz$-plane
respectively. First of all, lets compute the torque $\tau_x$ and
$\tau_y$ around the x-axis and y-axis at the ZMP on the support foot.

\begin{equation}
\tau_y = \overbrace{-m g (c_x - p_x)}^{\text{torque due to gravity}} + \overbrace{m \ddot{x} \cdot z_c}^{\text{torque due to acceleration of cart}}
\end{equation}

\begin{equation}
\tau_x = -m g (c_y - p_y) + m \ddot{y} \cdot z_c
\end{equation}

Please note the similarity to the equations \ref{eq:lip-y} and
\ref{eq:lip-x} when assuming the base of the pendulum is located at $p$.
If we now use the property of the ZMP that the torque around the $x$ and
$y$-axis is zero, we can solve for the ZMP position $p$:

\begin{equation} \label{eq:zmp-x}
p_x = c_x - \frac{z_c}{g} \ddot{c_x}
\end{equation}

\begin{equation} \label{eq:zmp-y}
p_y = c_y - \frac{z_c}{g} \ddot{c_y}
\end{equation}

\todo{Maybe describe the full-body methode to compute the ZMP}

\section{Simulating rigid body
dynamics}\label{simulating-rigid-body-dynamics}

\todo{short introduction how that works and some problems with the approach}

\chapter{Pattern generator}\label{pattern-generator}

To generate a walking pattern for a bipedal robot two basic approaches
are common:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate (or modify) foot trajectories that realize a prescribed
  trajectory of the CoM
\item
  Generate a CoM trajectory for prescribed foot trajectories
\end{enumerate}

The first approach is generally used for implementing pattern generators
soley based on the 3D-LIPM model. \todo{citation needed}

The second approach is the more versatile one, since it is easy to
incorporate constrains of our environment (e.g.~only limited foot holds)
in the input of the pattern generator. However care must be taken while
chosing adequate step width and step length parameters for the foot
trajectory, so that they can actually be realized by the robot.

The pattern generator proposed by Kajita et al. \todo{add citation}
based on Preview Control realizes the second approach. We will discuss
the theoretical background of this pattern generator here in more
detail, since all pattern that we used where generated that way.

\section{Computing the CoM from a reference
ZMP}\label{computing-the-com-from-a-reference-zmp}

As we saw in the section \ref{section:table-cart} it is easy to compute
the resulting ZMP given the CoM and its acceleration. However for
generating the walking pattern, we want to compute the CoM trajectory
from a given ZMP. If you rearange the equations \ref{eq:zmp-x} and
\ref{eq:zmp-y} you see that we have to solve a second order differential
equations:

\begin{equation} \label{eq:com-x}
c_x = \frac{z_c}{g} \cdot \ddot{c_x} + p_x
\end{equation}

\begin{equation} \label{eq:com-y}
c_y = \frac{z_c}{g} \cdot \ddot{c_y} + p_y
\end{equation}

There are several ways to solve this differential equations, for example
by transforming them to the frequency-domain. This however would mean,
the ZMP trajectory needs to be transformed to the frequency domain as
well, e.g.~using Fast Fourier Transformation. This has two main
problems:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  It has a significant computational overhead. (For FFT the additional
  runtime would be in $O(n \log n)$)
\item
  We need to know the whole ZMP trajectory in advance.
\end{enumerate}

Instead Kajita et. al. chose to define a dynamic system in the time
domain that describes the CoM movement.

\subsection{Pattern generation as dynamic
system}\label{pattern-generation-as-dynamic-system}

\todo{maybe do a formal introduction into dynamic system and the state space approach}

For simplicity we will only focus on the dynamic description of one
dimension, as the other one is analogous. To transform the equations to
a strictly proper dynamical system, we need to determine the state
vector of our system. For the table-cart model it suffices to know the
position, velocity and acceleration of the cart. Thus the state-vector
is defined as $x = (c_x, \dot{c_x}, \ddot{c_x})$. We can define the
evolution of the state vector as follows:

\begin{equation} \label{eq:dyn-system}
\frac{d}{dt} \left(\begin{array}{c}
c_x \\
\dot{c_x} \\
\ddot{c_x} \\
\end{array} \right)
=
\overbrace{
\left(\begin{array}{ccc}
0 & 1 & 0\\
0 & 0 & 1 \\
0 & 0 & 0 \\
\end{array}\right)
}^{ =: A_0}
\cdot
\left(\begin{array}{c}
c_x \\
\dot{c_x} \\
\ddot{c_x} \\
\end{array}\right)
+
\overbrace{
\left(\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
1 & 0 & 0\\
\end{array}\right)
}^{ =: B_0}
u
\end{equation}

As you can see the jerk of the CoM was introduced as an input
$u_x = \frac{d}{dt} \ddot{c_x}$ into the dynamic system.

We use equation \ref{eq:zmp-x} to calculate the actual output of the
dynamic system the resulting zmp, that will be controlled:

\begin{equation} \label{eq:zmp-x-output}
p_x =
\left(\begin{array}{ccc}
1 & 0 & \frac{-z_c}{g} \\
\end{array}\right)
\cdot
\left(\begin{array}{c}
c_x \\
\dot{c_x} \\
\ddot{c_x} \\
\end{array}\right)
\end{equation}

Using this formulation of the dynamic system we need to derive the
evolution of our state vector using the state-transition matrix. Since
our input ZMP trajectory will consist of discrete samples at equal time
intervals $T$ we define the discrete state as $x[k] := x(k \cdot T)$.
Please note that this system is a linear time-invariant system (LTI),
and both matrices $A_0$ and $B_0$ are constant. We can therefore use the
standart approach to solve this system using the equation:

\begin{equation}
x(t) = e^{A_0 \cdot (t - \tau)} x(\tau) + \int^t_\tau e^{A_0 \cdot (t - \lambda)} B_0 u(\lambda) d\lambda
\end{equation}

In our discrete case that becomes:

\begin{eqnarray} \label{eq:state-transition-discrete}
x[k+1] & = & e^{A_0 \cdot ((k+1)T - kT)} x[k] + \int^{(k+1)T}_{kT} e^{A_0 \cdot ((k+1)T - \lambda)} B_0 u(\lambda) d\lambda \\
       & = & e^{A_0 \cdot T} x[k] + \left(\int^{(k+1)T}_{kT} e^{A_0 \cdot ((k+1)T - \lambda)} d\lambda \right) \cdot B_0 u[k]\\
       & = & e^{A_0 \cdot T} x[k] + \left(\int^{0}_{T} e^{A_0 \cdot \lambda} d\lambda\right) \cdot B_0 u[k]
\end{eqnarray}

Keep in mind that $u(\lambda) = u[k], \lambda \in (kT, (k+1)T)$ so we
can move it outside of the integral. Let us first compute a general
solution for the matrix exponential $e^{A_0 \cdot t}$. It is easy to see
that $A_0$ is nilpotent and $A_0^3 = 0$, thus the computation simpilfies
to the following:

\begin{equation}
e^{A_0 t} := \sum^{\infty}_{i=0} \frac{(A_0 \cdot t)^i}{i!} = I + A_0 \cdot t + A_0^2 \cdot \frac{t^2}{2} + 0
=
\left(\begin{array}{ccc}
1 & t & \frac{t^2}{2}\\
0 & 1 & t \\
0 & 0 & 1 \\
\end{array}\right)
\end{equation}

Using that computing the integral in \ref{eq:state-transition-discrete}
is quite easily:

\begin{equation}
\int^{0}_{T} e^{A_0 \cdot \lambda} d\lambda =  -\int^{T}_{0} \left(\begin{array}{ccc}1 & t & \frac{t^2}{2}\\0 & 1 & t\\ 0 & 0 & 1\end{array}\right) dt
                                            =  -\left.\left(\begin{array}{ccc} %
                                                          t & \frac{t^2}{2} & \frac{t^3}{6} \\ %
                                                          0 & t             & \frac{t^2}{2} \\ %
                                                          0 & 0             & t %
                                                 \end{array}\right)\right|_{0}^{T}\\
                                            =   \left(\begin{array}{ccc} %
                                                          T & \frac{t^2}{2} & \frac{T^3}{6} \\ %
                                                          0 & T             & \frac{T^2}{2} \\ %
                                                          0 & 0             & T %
                                                \end{array}\right)
\end{equation}

Substituting the results in \ref{eq:state-transition-discrete} yields:

\begin{eqnarray} \label{eq:state-transition-result}
x[k+1] & = &  \overbrace{\left(\begin{array}{ccc} %
                     T & \frac{t^2}{2} & \frac{T^3}{6} \\ %
                     0 & T             & \frac{T^2}{2} \\ %
                     0 & 0             & T %
               \end{array}\right)}^{=: A} x[k]
             + \overbrace{\left(\begin{array}{ccc} %
                      \frac{T^3}{6} \\ %
                      \frac{T^2}{2} \\ %
                      T %
               \end{array}\right)}^{=: B} \cdot u_x[k]
\end{eqnarray}

\subsection{Controlling the dynamic
system}\label{controlling-the-dynamic-system}

To control this dynamic system we need to determine an adequate control
input $u_x$ to realize the reference ZMP trajectory. A performence index
$J_x$ for a given control input $u_x$ is needed to formalize what a
``good'' control input would be. A naive performence index could be:

\begin{equation}
J_x[k] := (p^{ref}_x[k] - p_x[k])^2
\end{equation}

To minimize it, we need to find $u_x$ for which $p_x = p^{ref}_x$. By
substituting $p_x[k]$ with \ref{eq:zmp-x-output} and $x[k]$ with
\ref{eq:state-transition-result} this yields:

\begin{equation}
u_x[k] = \frac{p^{ref}_x[k+1] - C \cdot A \cdot x[k]}{C \cdot B} = \frac{p^{ref}_x[k+1] - (1, T, \frac{1}{2} T^2 -\frac{z_c}{g}) \cdot x[k]}{\frac{1}{6}T^3 - \frac{z_c}{g} T}
= \frac{p^{ref}_x[k+1] - p_x[k] - T \dot{c_x}[k] - \frac{1}{2} T^2 \ddot{c_x}[k]}{\frac{1}{6}T^3 - \frac{z_c}{g} T}
\end{equation}

To analyse the behaviour of this control law for $u_x$ we simulate the
rapid change of reference ZMP when changing the support foot.
\todo{insert plot}

As you can see the reference ZMP is perfectly tracked. However, the CoM
does not behave as expected. To achive the required ZMP position the CoM
will be \emph{accelerated indefinietly} in the opposite direction.
Clearly this is not desired and will lead to falling on a real robot. A
more sophisticated performence index is needed. To eventually reach a
stable state at which the CoM comes to rest, the performence index
should include a state feedback. Also note the large jerk that is
applied to the system when the reference ZMP position changes rappidly.
In a real mechanical system large jerks will lead to oszillations, which
will disturbe the system. Thus the performence index should also try to
limit the applied jerk.

Another problem becomes apparent when you think about the nature of a
controller: The controller starts to act \emph{after} we have a
deviation from our reference ZMP trajectory. Trying make this lag as
small as possible can lead to very high velocities, which might not be
realizable by motors of a robot. However we have at least limited
knowledge of the future reference trajectory. This knowledge can be
leveraged by using Preview Control, which considers the next $N$
timesteps for computing the performence index.

\todo{add citation katayama} Kajita et. al. use a performence index
proposed by Katayama et. al. to solve all of the problems above:

\begin{equation}
J_x[k] = \sum^{\infty}_{i=k} Q_e e[i]^2 + \Delta x[i]^T Q_x \Delta x[i] + R \Delta u_x[i]^2
\end{equation}

$Q_e$ is the error gain, $Q_x$ a symmetric non-negative definite matrix
(typically just a diagonal matrix) to weight the components of
$\Delta x[i]$ differently and $R > 0$. Conviently Katayama also derived
an optimal controller for this performence index, which is given by:

\begin{equation}
u[k] = -G_i \sum^k_i=0 e[k] - G_x x[k] - \sum^N_{j=1} G_p p^{ref}_x[k + j]
\end{equation}

The gains $G_i, G_x, G_p$, can be derived from the parameters of the
performence index. Since the calculation is quite elaborate we refer to
the cited article by Katayama p.~680 for more details.

\section{Implementation}\label{implementation}

\todo{block diagramm of architechture} To generate walking patterns
based on the ZMP preview control methode, the approach from Kajita was
implemented in a shared library. A front-end was developed to easily
change parameters, visualize and subsequently export the trajectory to
the MMM format. The implementation was build on a previous
implementation, which was refactored, extended and tuned with respect to
results from the dynamics simulation.

The pattern generator makes extensive usage of Simoxs VirtualRobot, for
providing a model of the robot and the associated task of compting the
forward- and inverse kinematics.

Generating a walking pattern consists of multiple steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate foot trajectories: \texttt{FootstepPlaner}
\item
  Generate reference ZMP trajectory: \texttt{ReferenceZMPPlaner}
\item
  Compute resulting ZMP and CoM trajectories: \texttt{ZMPPlaner}
\item
  Compute inverse kinematics: \texttt{WalkingIK}
\item
  Exporting or visualizing the trajectory: \texttt{TrajectoryExporter}
\end{enumerate}

Each step is contained in dedicated modules that can be easily replaced,
if needed. We will outline the implementation of each module seperately.

\subsection{Generating foot
trajectories}\label{generating-foot-trajectories}

To generate the foot trajectories several parameters are needed:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Step length
\item
  Step width (the distance between booth TCP on the feet)
\item
  Duration of the single support phase
\item
  Duration of the dual support phase
\end{itemize}

Implementation Dynamic simulation

\chapter{Controllers to stabilize a
trajectory}\label{controllers-to-stabilize-a-trajectory}

Theory Implementation Evaluation

\chapter{Push recovery}\label{push-recovery}

Theory Implementation Evaluation

\chapter{Results}\label{results}

Make sure that somewhere, either here or in the evaluation sections, you
show how you plotted the desired vs.~real zmp, even the phantom robot if
you want, and the graphics that you generated.

\chapter{Conclusions}\label{conclusions}

things to improve summary of work done and results

\bibliographystyle{dinat} %-Deutsch

\bibliography{ba}

\end{document}
